<!DOCTYPE html>

<html>
<head>
  <title>stream.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="compressor.html">
                compressor.js
              </a>
            
              
              <a class="source" href="connection.html">
                connection.js
              </a>
            
              
              <a class="source" href="framer.html">
                framer.js
              </a>
            
              
              <a class="source" href="http.html">
                http.js
              </a>
            
              
              <a class="source" href="https.html">
                https.js
              </a>
            
              
              <a class="source" href="stream.html">
                stream.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>stream.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> EventEmitter = require(<span class="string">'events'</span>).EventEmitter;
<span class="keyword">var</span> Duplex = require(<span class="string">'stream'</span>).Duplex;
<span class="keyword">var</span> utils = require(<span class="string">'../lib/utils'</span>);

exports.Stream = Stream;

<span class="keyword">var</span> MAX_HTTP_PAYLOAD_SIZE = <span class="number">16383</span>; <span class="comment">// TODO: this is repeated in multiple files</span>

<span class="function"><span class="keyword">function</span> <span class="title">Stream</span><span class="params">(log)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  Duplex.call(<span class="keyword">this</span>);

  <span class="keyword">this</span>.upstream = <span class="keyword">new</span> Duplex();
  <span class="keyword">this</span>._read = <span class="keyword">this</span>.upstream._read = <span class="function"><span class="keyword">function</span> <span class="title">noop</span><span class="params">()</span> {</span>};
  <span class="keyword">this</span>.upstream._write = <span class="keyword">function</span>(frame, encoding, done) {
    self.emit(<span class="string">'receiving'</span>, frame);
    done();
  };

  <span class="keyword">this</span>._log = log || require(<span class="string">'./utils'</span>).nolog;

  <span class="keyword">this</span>._initializeState();

  <span class="keyword">this</span>._initializeFlowControl();
}

Stream.prototype = Object.create(EventEmitter.prototype, { constructor: { value: Stream } });</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2>Managing the stream</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._send = <span class="function"><span class="keyword">function</span> <span class="title">_send</span><span class="params">(frame)</span> {</span>
  <span class="keyword">this</span>.upstream.push(frame);
  <span class="keyword">this</span>.emit(<span class="string">'sending'</span>, frame);
};

Stream.prototype.promise = <span class="function"><span class="keyword">function</span> <span class="title">promise</span><span class="params">(headers)</span> {</span>
  <span class="keyword">this</span>._send({
    type: <span class="string">'PUSH_PROMISE'</span>,
    headers: headers
  });
};

Stream.prototype.open = <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">(headers, priority)</span> {</span>
  <span class="keyword">this</span>._send({
    type: <span class="string">'HEADERS'</span>,
    priority: priority,
    headers: headers
  });
};


Stream.prototype.close = <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>._send({
    type: <span class="string">'RST_STREAM'</span>
  });
};

Stream.prototype.reset = <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">(error)</span> {</span>
  <span class="keyword">this</span>._send({
    type: <span class="string">'RST_STREAM'</span>,
    error: error
  });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2><a href="http://tools.ietf.org/id/draft-unicorn-httpbis-http2-01.html#StreamStates">Stream States</a></h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <pre><code>                      +--------+
                PP    |        |    PP
             ,--------|  idle  |--------.
            /         |        |         \
           v          +--------+          v
    +----------+          |           +----------+
    |          |          | H         |          |
,---| reserved |          |           | reserved |---.
|   | (local)  |          v           | (remote) |   |
|   +----------+      +--------+      +----------+   |
|      |          ES  |        |  ES          |      |
|      | H    ,-------|  open  |-------.      | H    |
|      |     /        |        |        \     |      |
|      v    v         +--------+         v    v      |
|   +----------+          |           +----------+   |
|   |   half   |          |           |   half   |   |
|   |  closed  |          | R         |  closed  |   |
|   | (remote) |          |           | (local)  |   |
|   +----------+          |           +----------+   |
|        |                v                 |        |
|        |  ES / R    +--------+  ES / R    |        |
|        `-----------&gt;|        |&lt;-----------&#39;        |
|  R                  | closed |                  R  |
`--------------------&gt;|        |&lt;--------------------&#39;
                      +--------+</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._initializeState = <span class="function"><span class="keyword">function</span> <span class="title">_initializeState</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.state = <span class="string">'IDLE'</span>;
  <span class="keyword">this</span>.on(<span class="string">'sending'</span>, <span class="keyword">this</span>._transition.bind(<span class="keyword">this</span>, <span class="literal">true</span>));
  <span class="keyword">this</span>.on(<span class="string">'receiving'</span>, <span class="keyword">this</span>._transition.bind(<span class="keyword">this</span>, <span class="literal">false</span>));
};

Stream.prototype._setState = <span class="function"><span class="keyword">function</span> <span class="title">transition</span><span class="params">(state)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== state) {
    <span class="keyword">this</span>._log.debug({ state: state }, <span class="string">'State transition'</span>);
    <span class="keyword">this</span>.emit(<span class="string">'state'</span>, state);
    <span class="keyword">this</span>.state = state;
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>_transition</code> is called every time there&#39;s an incoming or outgoing frame. It manages state
transitions, and detects stream errors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._transition = <span class="function"><span class="keyword">function</span> <span class="title">transition</span><span class="params">(sending, frame)</span> {</span>
  <span class="keyword">var</span> receiving = !sending;
  <span class="keyword">var</span> error = <span class="literal">false</span>;

  <span class="keyword">switch</span> (<span class="keyword">this</span>.state) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>All streams start in the &quot;idle&quot; state. In this state, no frames have been exchanged.</p>
<ul>
<li>Sending or receiving a HEADERS frame causes the stream to become &quot;open&quot;.</li>
<li>Sending a PUSH_PROMISE frame marks the associated stream for later use. The stream state
for the reserved stream transitions to &quot;reserved (local)&quot;.</li>
<li>Receiving a PUSH_PROMISE frame marks the associated stream as reserved by the remote peer.
The state of the stream becomes &quot;reserved (remote)&quot;.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'IDLE'</span>:
      <span class="keyword">if</span> (frame.type === <span class="string">'HEADERS'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'OPEN'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (frame.type === <span class="string">'PUSH_PROMISE'</span>) {
        <span class="keyword">this</span>._setState(sending ? <span class="string">'RESERVED_LOCAL'</span> : <span class="string">'RESERVED_REMOTE'</span>);
      } <span class="keyword">else</span> { <span class="comment">// TODO: Not well defined. https://github.com/http2/http2-spec/issues/165</span>
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A stream in the &quot;reserved (local)&quot; state is one that has been promised by sending a
PUSH_PROMISE frame.</p>
<ul>
<li>The endpoint can send a HEADERS frame. This causes the stream to open in a &quot;half closed
(remote)&quot; state.</li>
<li>Either endpoint can send a RST_STREAM frame to cause the stream to become &quot;closed&quot;. This
releases the stream reservation.</li>
<li>An endpoint MUST NOT send any other type of frame in this state.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'RESERVED_LOCAL'</span>:
      <span class="keyword">if</span> (sending &amp;&amp; frame.type === <span class="string">'HEADERS'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'HALF_CLOSED_REMOTE'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> ( sending &amp;&amp; frame.type === <span class="string">'RST_STREAM'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'CLOSED'</span>);
      } <span class="keyword">else</span> { <span class="comment">// TODO: Not well defined. https://github.com/http2/http2-spec/issues/165</span>
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A stream in the &quot;reserved (remote)&quot; state has been reserved by a remote peer.</p>
<ul>
<li>Either endpoint can send a RST_STREAM frame to cause the stream to become &quot;closed&quot;. This
releases the stream reservation.</li>
<li>Receiving a HEADERS frame causes the stream to transition to &quot;half closed (local)&quot;.</li>
<li>Receiving any other type of frame MUST be treated as a stream error of type PROTOCOL_ERROR.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'RESERVED_REMOTE'</span>:
      <span class="keyword">if</span> (frame.type === <span class="string">'RST_STREAM'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'CLOSED'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (receiving &amp;&amp; frame.type === <span class="string">'HEADERS'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'HALF_CLOSED_LOCAL'</span>);
      } <span class="keyword">else</span> {
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The &quot;open&quot; state is where both peers can send frames. In this state, sending peers observe
advertised stream level flow control limits.</p>
<ul>
<li>From this state either endpoint can send a frame with a END_STREAM flag set, which causes
the stream to transition into one of the &quot;half closed&quot; states: an endpoint sending a
END_STREAM flag causes the stream state to become &quot;half closed (local)&quot;; an endpoint
receiving a END_STREAM flag causes the stream state to become &quot;half closed (remote)&quot;.</li>
<li>Either endpoint can send a RST_STREAM frame from this state, causing it to transition
immediately to &quot;closed&quot;.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'OPEN'</span>:
      <span class="keyword">if</span> (frame.flags &amp;&amp; frame.flags.END_STREAM) {
        <span class="keyword">this</span>._setState(sending ? <span class="string">'HALF_CLOSED_LOCAL'</span> : <span class="string">'HALF_CLOSED_REMOTE'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (frame.type === <span class="string">'RST_STREAM'</span>) {
        <span class="keyword">this</span>._setState(<span class="string">'CLOSED'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (frame.type !== <span class="string">'DATA'</span>) { <span class="comment">// TODO: Not well defined. https://github.com/http2/http2-spec/issues/165</span>
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A stream that is &quot;half closed (local)&quot; cannot be used for sending frames.</p>
<ul>
<li>A stream transitions from this state to &quot;closed&quot; when a frame that contains a END_STREAM
flag is received, or when either peer sends a RST_STREAM frame.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'HALF_CLOSED_LOCAL'</span>:
      <span class="keyword">if</span> (frame.type === <span class="string">'RST_STREAM'</span> || (receiving &amp;&amp; frame.flags &amp;&amp; frame.flags.END_STREAM)) {
        <span class="keyword">this</span>._setState(<span class="string">'CLOSED'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (sending) { <span class="comment">// TODO: what is valid here?</span>
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A stream that is &quot;half closed (remote)&quot; is no longer being used by the peer to send frames.
In this state, an endpoint is no longer obligated to maintain a receiver flow control window
if it performs flow control.</p>
<ul>
<li>If an endpoint receives additional frames for a stream that is in this state it MUST
respond with a stream error of type STREAM_CLOSED.</li>
<li>A stream can transition from this state to &quot;closed&quot; by sending a frame that contains a
END_STREAM flag, or when either peer sends a RST_STREAM frame.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'HALF_CLOSED_REMOTE'</span>:
      <span class="keyword">if</span> (frame.type === <span class="string">'RST_STREAM'</span> || (sending &amp;&amp; frame.flags &amp;&amp; frame.flags.END_STREAM)) {
        <span class="keyword">this</span>._setState(<span class="string">'CLOSED'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (receiving) { <span class="comment">//  // TODO: what is valid here?</span>
        error = <span class="literal">true</span>;
      }
      <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The &quot;closed&quot; state is the terminal state.</p>
<ul>
<li>An endpoint MUST NOT send frames on a closed stream. An endpoint that receives a frame
after receiving a RST_STREAM or a frame containing a END_STREAM flag on that stream MUST
treat that as a stream error of type STREAM_CLOSED.</li>
<li>If this state is reached as a result of sending a RST_STREAM frame, the peer that receives
the RST_STREAM might have already sent - or enqueued for sending - frames on the stream
that cannot be withdrawn. An endpoint that sends a RST_STREAM frame MUST ignore frames that
it receives on closed streams after it has sent a RST_STREAM frame. An endpoint MAY choose
to limit the period over which it ignores frames and treat frames that arrive after this
time as being in error.</li>
<li>An endpoint might receive a PUSH_PROMISE frame after it sends RST_STREAM. PUSH_PROMISE
causes a stream to become &quot;reserved&quot;. If promised streams are not desired, a RST_STREAM
can be used to close any of those streams.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">case</span> <span class="string">'CLOSED'</span>:
      error = <span class="literal">true</span>;
      <span class="keyword">break</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>TODO: DATA frame handling. Sending is allowed in HALF_CLOSED_REMOTE and OPEN?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (error) {
    <span class="keyword">if</span> (sending) {
      <span class="keyword">this</span>._log.error({ frame: frame, state: <span class="keyword">this</span>.state }, <span class="string">'Stream error: sending illegal frame.'</span>);
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Sending illegal frame ('</span> + frame.type + <span class="string">') in '</span> + <span class="keyword">this</span>.state + <span class="string">' state.'</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>._log.error({ frame: frame, state: <span class="keyword">this</span>.state }, <span class="string">'Stream error: received illegal frame.'</span>);
      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="string">'PROTOCOL_ERROR'</span>);
    }
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2><a href="http://tools.ietf.org/id/draft-unicorn-httpbis-http2-01.html#rfc.section.6.9">Flow control</a></h2>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Flow control in HTTP/2.0 is implemented using a window kept by each sender on every stream.
The flow control window is a simple integer value that indicates how many bytes of data the
sender is permitted to transmit. Two flow control windows are applicable; the stream flow control
window and the connection flow control window.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._initializeFlowControl = <span class="function"><span class="keyword">function</span> <span class="title">_initializeFlowControl</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.window = INITIAL_WINDOW_SIZE;
  <span class="keyword">this</span>.on(<span class="string">'receiving'</span>, <span class="keyword">function</span>(frame) {
    <span class="keyword">if</span> (frame.type === <span class="string">'WINDOW_UPDATE'</span>) {
      <span class="keyword">this</span>._updateWindow(frame);
    }
  });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>When a HTTP/2.0 connection is first established, new streams are created with an initial flow
control window size of 65535 bytes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> INITIAL_WINDOW_SIZE = <span class="number">65535</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>A SETTINGS frame can alter the initial flow control window size for all current streams. When the
value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow
control windows that it maintains by the difference between the new value and the old value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype.setInitialWindowSize = <span class="function"><span class="keyword">function</span> <span class="title">setInitialWindowSize</span><span class="params">(initialWindowSize)</span> {</span>
  <span class="keyword">this</span>.window = <span class="keyword">this</span>.window - <span class="keyword">this</span>._initialWindowSize + initialWindowSize;
  <span class="keyword">this</span>._initialWindowSize = initialWindowSize;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Flow control can be disabled for all streams on the connection using the
SETTINGS_FLOW_CONTROL_OPTIONS setting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype.disableFlowControl = <span class="function"><span class="keyword">function</span> <span class="title">disableFlowControl</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.window = <span class="literal">Infinity</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount
specified in the frame.</p>
<p>Flow control can be disabled for an individual stream by sending a WINDOW_UPDATE with the
END_FLOW_CONTROL flag set. The payload of a WINDOW_UPDATE frame that has the END_FLOW_CONTROL
flag set is ignored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._updateWindow = <span class="function"><span class="keyword">function</span> <span class="title">_received</span><span class="params">(frame)</span> {</span>
  <span class="keyword">if</span> (frame.flags.END_FLOW_CONTROL) {
    <span class="keyword">this</span>.disableFlowControl();
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.window += frame.window_size;
  }
  <span class="keyword">this</span>.emit(<span class="string">'window_update'</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>After sending a flow controlled frame, the sender reduces the space available in both windows by
the length of the transmitted frame. For flow control calculations, the 8 byte frame header is
not counted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Stream.prototype._write = <span class="function"><span class="keyword">function</span> <span class="title">_write</span><span class="params">(buffer, encoding, done)</span> {</span>
  <span class="keyword">var</span> chunks = utils.cut(buffer, MAX_HTTP_PAYLOAD_SIZE);
  <span class="keyword">var</span> sent = <span class="number">0</span>;

  <span class="keyword">while</span> (chunks.length &gt; <span class="number">0</span> &amp;&amp; chunks[<span class="number">0</span>].length &lt;= <span class="keyword">this</span>.window) {
    <span class="keyword">var</span> chunk = chunks.shift();
    sent += chunk.length;
    <span class="keyword">this</span>.window -= chunk.length;
    <span class="keyword">this</span>._send({
      type: <span class="string">'DATA'</span>,
      flags: {},
      data: chunk
    });
  }

  <span class="keyword">if</span> (chunks.length === <span class="number">0</span>) {
    done();
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.once(<span class="string">'window_update'</span>, <span class="keyword">this</span>._write.bind(<span class="keyword">this</span>, buffer.slice(sent), encoding, done));
  }
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
